<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ETISS 0.8.0: /home/travis/build/tum-ei-eda/etiss/include/etiss/mm/README.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ETISS 0.8.0
   </div>
   <div id="projectbrief">ExtendableTranslatingInstructionSetSimulator(version0.8.0)</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/travis/build/tum-ei-eda/etiss/include/etiss/mm/README.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="README_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Memory Management Unit</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;Memory management unit is the essential part to translate virtual memory address to physical memory address and perform memory protection.  In modern operating systems except for some Real-time Operating Systems (RTOS), the MMU support is inseparable. For example, the `Linux` kernel lives in the virtual address space after ~2000 cycles. It is quite early in terms of the kernel execution. Meanwhile, ETISS is designed to be an Instruction Set Simulation framework, so that the MMU implementation should follow the philosophy as well, to be extendable for other architectures. </div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;## Page Table Entry (PTE)</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;The Page Table Entry (PTE) format is architecture-dependent which specifies the bit field for protection flags and the Physical Page Number. During memory protection check and page table walking, these bit fields will be frequently checked, read or written. In order to mitigate bit manipulation for PTE, a ***PTEFormatBuilder*** and a ***PTEFormat*** singleton class are integrated into ETISS. With simple syntax, PTE format could be easily modeled and every PTE can be manipulated with the bit field name specified by the builder.  A brief example is given in the following.</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;```cpp</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;// Bit field for Page Table Entry (PTE)</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;PTEFormatBuilder::Instance().AddPPNBitField(53,10).AddFlag(&quot;D&quot;,7).</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                                                   AddFlag(&quot;A&quot;,6).AddFlag(&quot;G&quot;,5).AddFlag(&quot;U&quot;,4).</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                                                   AddFlag(&quot;X&quot;,3).AddFlag(&quot;W&quot;,2).AddFlag(&quot;R&quot;,1).</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                                   AddFlag(&quot;V&quot;,0).AddFlag(&quot;MODE&quot;,63,60).</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                                                   AddFlag(&quot;ASID&quot;,59,44);</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;```</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;##Translation Lookaside Table (TLB)</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;The MMU would typically introduce overhead for the memory access because it accommodates in the middle way between the core and caches. Thanks to the locality property of the memory access, we could add a Translation Lookaside Buffer (TLB) in MMU to expedite **virtual to physical address translation**. The MMU translation would look up TLB at first to find whether virtual to physical address mapping is cached in TLB. If so the protection flags are checked to validate the memory access. Afterward, the `Physical Page Number (PPN)` will be extracted from the found PTE and added by page offset to obtain the physical address.  When the mapping is not located in TLB, page talk walking functionalities will be invoked to perform actual translation and then cache the mapping into TLB. </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;## Fault handling in the MMU</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;Considering that complex MMUs are probably designed in the future, the MMU has implemented a light-weight `fault handler system`. If an unexpected issue happens in the PTE manipulation or in the TLB operation, an MMU specific fault will be thrown until the MMU catch the fault and try to handle it. When the MMU does not handle it, it will further throw out the ETISS-specific fault to the simulator. This design is useful since it leaves an interface to configure MMU with the various feature. </div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;## Future work</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;In most design, the cache is located after the MMU (physically tagged physically indexed) or in parallel with the MMU (physically tagged virtually indexed). In ETISS, data access is not cached, so it would not burden the MMU at all. However,  ETISS caches instructions to speed up the simulation. The best attempt is to make ETISS instruction cache as widely adopted **physically addressed cache**. Nevertheless, since ETISS caches the compiled binary code as shared libraries, and uses both physical address and current pc, it is impossible to use the cache merely with the physical address. The most straightforward solution is to disable cache at all, which will introduce significant penalty while every instruction has to be repeatedly  translated and compiled by `Just-In-Time (JIT)` compiler. Redesigning the instruction cache means to modify the whole `Dynamic Binary Translation (DBT)` infrastructure in ETISS, which is quite risky when designing the MMU.  An alternative is to introduce the rarely used **virtually addressed cache**. Since only the instructions are cached, and we are targeting to run a single kernel process, it could be a temporary workaround. However, it should be upgraded to **physically addressed cache** to run a full kernel stack.</div></div><!-- fragment --></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Sep 3 2020 06:12:00 for ETISS 0.8.0 by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
